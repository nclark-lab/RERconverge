---
title: "RERconverge New Pipeline Walkthrough"
bibliography: RERConverge.bib
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    output_dir: "./docs/"
    css: custom.css
    self_contained: true
    toc: yes
  pdf_document:
    toc: yes
authors: Maria Chikina
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, results='hide', message=FALSE)
```





\newpage

This walkthrough provides instructions for using the updated and faster RERconverge pipeline. In this brief walkthough we are assuming basic familiarity for RERconverge functionality.  For an extensive explanation of RERconverge  see the  [original walkthrough](FullWalkthroughUTD.html). 

## Overview
There are some  important differences between the original and new versions


1. The results  of the output are not exactly the same. One of the main calculations performed by RERconverge is turning evolutionary rates into relative rates by correcting for the expected evolutionary rate. The methods differ in how the expected rate is computed. The original method computes a different normalization vector for every gene/element using the set all other genes/elements that have all of the same species as a subset. This is quite time consuming but exactly recapitulates the calculation done in some of the original evolutionary rate correlation papers.  The new method computes a single normalization vector that is used for all elements. This may not sufficiently capture all of the relevant variation. To account for this we have included PC normalization as an option where the data can be normalized for any number of principle components thus affording the ability to capture and correct for more axes of variation. Extensive testing on datasets with  known ground truth showed that the new pipeline with the simpler normalization approach os not inferior to the original one. 

2. The calculations are broken into steps in a different way. The new pipeline computes residuals for all possible paths not just the maximally independent set. This complete set of residuals is useful for other downstream analysis and is not time intensive to compute. There is a seperate function that normalized the results and returns the maximally independent paths which corresponds to the RER matrix that is returned by `getAllResiduals` in the original pipeline.


3. The internal representation of the trees and paths are different. We are now using functions provided by `TreeTools` that greatly speed up some of the tree matching computations. However, the trees need to be in a different order. Thus, while you can use the objects generated by `readTrees2` in the original pipeline the reverse is not the case. You cannot feed objects generated by `readTrees` into the new pipeline as you will get an error.

## Comparing the original and new pipelines

### Orignal pipeline steps


In R, load the RERConverge library. 

```{r results='hide', message = FALSE, warning = FALSE, cache = TRUE}
library(RERconverge)

```
From the original tutorial we would perform these steps.

```{r results='hide', message = FALSE, warning = FALSE, cache = TRUE}
rerpath = find.package('RERconverge') #If this errors, there is an issue with installation
toytreefile = "subsetMammalGeneTrees.txt"
toyTrees=readTrees(paste(rerpath,"/extdata/",toytreefile,sep=""), max.read = 500)
data("logAdultWeightcm")
mamRERw = getAllResiduals(toyTrees,useSpecies=names(logAdultWeightcm),   transform = "sqrt", weighted = T, scale = T)
```

### New pipeline steps

#### Read in the trees

 We use `readTrees2` which has exactly the same elements in the output except that the trees and paths are ordered differently. It is also considerably faster.


```{r, cache = TRUE, results='hide', message=FALSE}
toyTreesNew=readTrees2(paste(rerpath,"/extdata/",toytreefile,sep=""))
```


```{r, cache=FALSE}
map=mapIndex(toyTreesNew, toyTrees)
plot(toyTreesNew$paths[1:10,], toyTrees$paths[1:10, map], xlab="new paths", ylab="original paths")
abline(a=0,b=1, lwd=2, col=3)
```

#### Transform the trees

The next step is to transform the treesObj. This transformation has the same purpose as the one in the original `getAllResiduals`. Imputing is optional but recommended as it allows for principle component normalization in the next step.
```{r, cache=TRUE}
toyTreesSq=transformPaths(toyTreesNew, transform = "sqrt", impute = T)
```


#### Compute the residuals

The next step is to compute the residuals
```{r, cache=TRUE, results='hide', message=FALSE}
RERall = getAllResiduals2(toyTreesSq,useSpecies=names(logAdultWeightcm), n.pcs = 0)
```

To use PC normalization you can specify the number of PCs to use. Here is an example using 2 PCs.

```{r, cache=TRUE}
RERallPC2 = getAllResiduals2(toyTreesSq,useSpecies=names(logAdultWeightcm), n.pcs = 2.)
```

The `RERall` is not a matrix but is list object which contains a matrix called `allresiduals`. Unlike the previous `getAllResiduals` method these are all the residuals that can be in principle computed and not the maximal independent set that would be used for downstream analysis. Also, at this point no column-wise normalization (achieved with `scale` in the original function) has been performed.

#### Extract the RER matrix

This function performs column-wise normalization and extracts the maximally independent set. The "scale" normalization is default.

```{r, cache=TRUE}
rmat=getRMat(RERall, norm = "scale")
```



```{r, cache=TRUE}
rmatPC2=getRMat(RERallPC2, norm="scale")
```


## Comparing the results

Using the map above we can directly compare the results. The computed residuals are indeed correlated but different. This difference does not appear to be biologically important. In all of our test the biological signal with consistent between the original and new pipeline.

```{r, cache=TRUE}
par(mfrow=c(1,2))
plotWithCor(mamRERw[, map],rmat)
plotWithCor( mamRERw[, map],rmatPC2)
```


All of the other function work as before. We can make a tree plot by supplying the trees object `toyTreesNew` and the RER matrix `rmat`


## Performing downstream analysis

```{r fig2, fig.height=9,fig.width=10, warning = FALSE, cache = TRUE, tidy = FALSE}
#plot RERs
par(mfrow=c(1,1))
phenvExample <- foreground2Paths(c("Vole","Squirrel"),toyTreesNew,clade="terminal")
plotRers(rmat,"BEND3",phenv=phenvExample) #plot RERs
```

```{r fig2b, fig.height=9,fig.width=10, warning = FALSE, cache = TRUE, tidy = FALSE}
#plot RERs as tree
par(mfrow=c(1,1))
bend3rers = returnRersAsTree(toyTreesNew, rmat, "BEND3", plot = TRUE,
                             phenv=phenvExample) #plot RERs
```
